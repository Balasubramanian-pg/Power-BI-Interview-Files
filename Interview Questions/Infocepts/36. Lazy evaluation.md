## 36. Can you explain **lazy evaluation** in the DAX formula engine?

Lazy evaluation is a core optimization strategy used by the DAX formula engine to avoid doing unnecessary work.

#### What is Lazy Evaluation?
*   The principle is simple: **Don't calculate something until you absolutely have to.**
*   The DAX engine will not evaluate every part of a complex formula from the start. It will only compute the parts that are required to produce the final result requested by the visual.

#### How it Works in Practice
*   **Variables (VAR):** This is the most common example. When you define a variable in a DAX measure, the expression inside the variable is **not** calculated at the point of definition. It is only calculated if and when that variable is actually used later in the `RETURN` statement.
   ```dax
   My Measure =
   VAR HighCost = CALCULATE(...) -- Not calculated yet
   VAR LowCost = CALCULATE(...)  -- Not calculated yet
   RETURN
       IF( [Total Sales] > 1000, HighCost, LowCost )
   ```
   In this example, if `[Total Sales]` is greater than 1000, only the `HighCost` variable's expression will ever be evaluated. The engine completely skips the calculation for `LowCost`, saving processing time.
*   **Conditional Logic (`IF`, `SWITCH`):** The engine only evaluates the branch of the condition that is met. In the example above, the expression in the "else" part of the `IF` statement is ignored if the condition is true.
*   **Logical Functions (`AND`, `OR`):** These functions use "short-circuiting."
    *   For `AND (Condition1, Condition2)`, if `Condition1` evaluates to `FALSE`, the engine knows the entire result must be `FALSE`, so it **never evaluates `Condition2`**.
    *   For `OR (Condition1, Condition2)`, if `Condition1` evaluates to `TRUE`, the engine knows the entire result must be `TRUE`, so it **never evaluates `Condition2`**.

#### Why It's Important
*   **Performance:** It is a major performance optimization, especially in complex measures with many variables and conditional paths. It allows you to write complex, readable code without paying a performance penalty for the parts that aren't needed in a given context.
*   **Debugging:** It explains why placing a computationally heavy piece of DAX inside a variable can be a good strategy, as it ensures the logic is only run when required.
