## 11. How does **column cardinality** affect VertiPaq compression efficiency?

#### What is VertiPaq and Cardinality?
*   **VertiPaq Engine:** The columnar, in-memory storage engine that powers Power BI Import models. It stores data column by column instead of row by row.
*   **Cardinality:** The number of unique or distinct values in a column.
    *   **Low Cardinality:** A column with few unique values (e.g., `[Gender]`, `[Year]`, `[Status]`).
    *   **High Cardinality:** A column with many unique values (e.g., `[TransactionID]`, `[EmailAddress]`, `[Timestamp]`).

#### The Impact on Compression
*   **Dictionary Encoding:** VertiPaq's primary compression method is dictionary encoding. For each column, it creates a dictionary of the unique values and then replaces the raw data in the column with small integer pointers to that dictionary.
*   **Low Cardinality Efficiency:**
    *   A low cardinality column (e.g., `[Status]` with values "Open", "Closed", "Pending") has a very small dictionary.
    *   The engine can store the entire column using tiny integers (e.g., 0, 1, 2), which takes up very little memory. This results in extremely high compression ratios.
*   **High Cardinality Inefficiency:**
    *   A high cardinality column (e.g., a primary key on a fact table with millions of rows) has a dictionary that is almost as large as the original data itself.
    *   The benefits of dictionary encoding are minimal, and the column consumes a large amount of memory, significantly increasing the model's size.

> **Key Takeaway:**
> * The size of a Power BI model is primarily driven not by the number of rows, but by the **cardinality of its columns**.
> * A single high-cardinality column can consume more memory than dozens of low-cardinality columns combined. This is why splitting `DateTime` columns into separate `Date` and `Time` columns is a common optimization technique.
