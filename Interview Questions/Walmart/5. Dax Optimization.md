### 5. & 7. How will you optimize the DAX code? What will be the checkpoints except these: we will use measures, light customer visuals, star schema, and data type?

This question appears twice. Here is a comprehensive list of DAX optimization techniques beyond the basics you've listed:

1. **Use Variables (VAR):** This is one of the most important optimization techniques.
    - **Why:** A variable stores the result of a DAX expression. If you use that result multiple times within the same measure, the expression is evaluated **only once**. Without variables, it would be re-evaluated each time it's referenced. This also dramatically improves code readability.
    - **Example:**
        
        ```Plain
        // Inefficient
        Profit Margin = DIVIDE([Total Profit], [Total Sales], 0) * 100
        
        // Efficient and Readable
        Profit Margin =
        VAR TotalProfit = [Total Profit]
        VAR TotalSales = [Total Sales]
        RETURN
            DIVIDE(TotalProfit, TotalSales, 0) * 100
        ```
        
2. **Minimize Context Transitions:** A context transition occurs when a row context is turned into a filter context, which is computationally expensive. This typically happens when you use `CALCULATE` inside an iterator function like `SUMX` or `FILTER`.
    - **Bad:** `SUMX(Sales, CALCULATE(SUM(Products[Price])))`
    - **Better:** Try to pre-calculate values in Power Query or use simpler measures that don't require nested `CALCULATE` inside iterators.
3. **Prefer Simple Filter Arguments in** `**CALCULATE**`**:** The `CALCULATE` function is highly optimized for simple, direct filter arguments (known as sargable predicates).
    - **Efficient:** `CALCULATE([Total Sales], 'Product'[Color] = "Red")`
    - **Inefficient:** `CALCULATE([Total Sales], FILTER(ALL('Product'), 'Product'[Color] = "Red"))`. The `FILTER` function is an iterator that scans the entire table, which is much slower.
4. **Use** `**DIVIDE()**` **instead of the** `**/**` **operator:** The `DIVIDE()` function is optimized to handle divide-by-zero errors gracefully and is more efficient than writing an `IF` statement to check for a zero denominator.
    - **Bad:** `IF( [Denominator] = 0, BLANK(), [Numerator] / [Denominator] )`
    - **Good:** `DIVIDE( [Numerator], [Denominator] )`
5. **Use** `**SELECTEDVALUE()**` **instead of** `**VALUES()**` **or** `**HASONEVALUE()**`**:** When you need to capture a single selection from a slicer or filter, `SELECTEDVALUE` is more concise, readable, and often more efficient than combining `HASONEVALUE` and `VALUES`.
6. **Avoid Using Entire Tables as Filters:** When filtering, be as specific as possible. Filtering by a single column is much faster than filtering by an entire table.
    - **Bad:** `CALCULATE([Total Sales], FILTER('Date', 'Date'[Year] = 2023))`
    - **Good:** `CALCULATE([Total Sales], 'Date'[Year] = 2023)` or even better, use the Time Intelligence functions `DATESYTD`, etc.
7. **Use** `**KEEPFILTERS**`**:** When you want to add a new filter within `CALCULATE` without overriding the existing external filter context, use `KEEPFILTERS`. This creates an intersection of filters rather than a replacement.
8. **Leverage Performance Analyzer:** Use the Performance Analyzer pane in Power BI Desktop. It records the time taken by each visual to render and allows you to copy the DAX query generated for that visual. You can then analyze this query in DAX Studio to understand bottlenecks.

